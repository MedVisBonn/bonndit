#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
================================================================================
Compute fiber orientation distribution functions for diffusion weighted MRI data
================================================================================
"""

import argparse
import errno
import os

import nibabel as nib
import numpy as np
from dipy.core.gradients import gradient_table
from dipy.io import read_bvals_bvecs

import bonndit.mtshore as bdshore
from bonndit import mtShoreModel, mtShoreFit
from bonndit.io import fsl_flip_signs_vec, fsl_to_worldspace
from bonndit.michi import fields, dwmri


# TODO: Add option to first compute the diffustion tensors which are needed to estimate the response functions.
# TODO: Add option to automatically build masks for csf gm wm.
# TODO: Handle nrrd as well as nii input
# TODO: Save in different output formats
# TODO: Add logging and make it default

def main():
    parser = argparse.ArgumentParser(
        description='This script computes fiber orientation distribution functions (fODFs) \
        as described in "Versatile, Robust and Efficient Tractography With Constrained Higher \
        Order Tensor fODFs" by Ankele et al. (2017). It is assumed that the input data is saved \
        using FSL.', add_help=False)

    parser.add_argument('indir',
                        help='Folder containing all required input files')

    parser.add_argument('-o', '--outdir',
                          help='Folder in which the output will be saved (default: same as indir)')

    inputfiles = parser.add_argument_group('Custom input filenames', 'It is not recommended to specify a Specify custom names for input files.')
    inputfiles.add_argument('-d', '--data', default='data.nii.gz',
                            help='Diffusion weighted data (default: data.nii.gz)')
    inputfiles.add_argument('-e', '--dtivecs', default='dti_V1.nii.gz',
                            help='First eigenvectors of a DTI model (default: dti_V1.nii.gz)')
    inputfiles.add_argument('-a', '--dtifa', default='dti_FA.nii.gz',
                            help='Fractional anisotropy values from a DTI model (default: dti_FA.nii.gz)')
    inputfiles.add_argument('-m', '--brainmask', default='mask.nii.gz',
                            help='Brain mask (default: mask.nii.gz)')
    inputfiles.add_argument('-W', '--wmmask', default='fast_pve_2.nii.gz',
                            help='White matter mask (default: fast_pve_2.nii.gz)')
    inputfiles.add_argument('-G', '--gmmask', default='fast_pve_1.nii.gz',
                            help='Gray matter mask (default: fast_pve_1.nii.gz)')
    inputfiles.add_argument('-F', '--csfmask', default='fast_pve_0.nii.gz',
                            help='Cerebrospinal fluid mask (default: fast_pve_0.nii.gz)')


    flags = parser.add_argument_group('flags (optional)', '')
    flags.add_argument("-h", "--help", action="help", help="Show this help message and exit")
    flags.add_argument('-v', '--verbose', action='store_true',
                       help='Show progress bars for calculation of the response function and the deconvolution')
    flags.add_argument('-R', '--responseonly', action='store_true',
                       help='Calculate and save only the response functions')
    flags.add_argument('-M', '--tissuemasks', action='store_true',
                       help='Output the DTI improved tissue masks (csf/gm/wm)')
    flags.add_argument('-L' '--log', action='store_true',
                       help='Enable logging, logs are saved in the output folder as "mtdeconv.log"')

    shoreopts = parser.add_argument_group('shore options (optional)', 'Optional arguments for the computation of \
    the shore response functions')
    shoreopts.add_argument('-r', '--order', default=4, type=int,
                        help='Order of the shore basis (default: 4)')
    shoreopts.add_argument('-z', '--zeta', default=700, type=float,
                           help='Radial scaling factor (default: 700)')
    shoreopts.add_argument('-t', '--tau', default=1 / (4 * np.pi ** 2), type=float,
                           help='q-scaling')
    shoreopts.add_argument('-f', '--fawm', default=0.7, type=float,
                           help='White matter fractional anisotropy threshold (default: 0.7)')

    deconvopts = parser.add_argument_group('deconvolution options (optional)', '')
    deconvopts.add_argument('-C', '--constraint', choices=['hpsd', 'nonneg', 'none'], default='hpsd',
                            help='Constraint for the fODFs (default: hpsd)')

    filenaming = parser.add_argument_group('file naming (optional)', 'Specify custom names for output files.')
    filenaming.add_argument('-S', '--responseout', default='response.npz',
                            help='Response function output name - filetype: .npz')

    multiprocessing = parser.add_argument_group('multiprocessing (optional)', 'Configure the multiprocessing behaviour \
    (only supported for Python 3)')
    multiprocessing.add_argument('-w', '--workers', default=None,
                                 help='Number of cpus (default: all available cpus)')

    args = parser.parse_args()
    order = args.order
    zeta = args.zeta
    tau = args.tau
    fawm = args.fawm
    verbose = args.verbose
    indir = args.indir

    # Load fractional anisotropy
    dti_fa = nib.load(os.path.join(indir, args.dtifa))

    # Load DTI mask
    dti_mask = nib.load(os.path.join(indir, args.brainmask))

    # Load and adjust tissue segmentation masks
    csf_mask = nib.load(os.path.join(indir, args.csfmask))
    gm_mask = nib.load(os.path.join(indir, args.gmmask))
    wm_mask = nib.load(os.path.join(indir, args.csfmask))

    wm_mask, gm_mask, csf_mask = bdshore.dti_masks(wm_mask, gm_mask, csf_mask,
                                                   dti_fa, dti_mask, fawm)
    if args.tissuemasks:
        nib.save(wm_mask, os.path.join(args.outdir, 'wm_mask.nii.gz'))
        nib.save(gm_mask, os.path.join(args.outdir, 'gm_mask.nii.gz'))
        nib.save(csf_mask, os.path.join(args.outdir, 'csf_mask.nii.gz'))

    # Load first eigenvectors of a precalculated diffusion tensor
    dti_vecs = nib.load(os.path.join(indir, args.dtivecs))

    # Load diffusion weighted data
    data = nib.load(os.path.join(indir, args.data))

    # Load bvals and bvecs and initialize a GradientTable object
    bvals, bvecs = read_bvals_bvecs(os.path.join(indir, "bvals"),
                                   os.path.join(indir, "bvecs"))
    gtab = gradient_table(bvals, bvecs)

    # Flip sign of x-coordinate if affine determinant is positive and rotate to worldspace
    gtab = fsl_to_worldspace(data.affine, gtab)
    dti_vecs = fsl_flip_signs_vec(dti_vecs)

    # We need this Meta object for saving later
    _, _, meta = dwmri.load(os.path.join(indir, args.data))

    # Create outdir if it does not exists
    if not args.outdir:
        outdir = indir
    else:
        outdir = args.outdir

    if not os.path.exists(outdir):
        os.makedirs(outdir)

    # Check if response is already in the output folder
    if not args.responseonly:
        if os.path.exists(os.path.join(outdir, args.responseout)):
            fit = mtShoreFit.load(os.path.join(outdir, args.responseout))
            if verbose:
                print('Loaded existing response functions.')

        else:
            model = mtShoreModel(gtab, order, zeta, tau)
            fit = model.fit(data, dti_vecs, wm_mask, gm_mask, csf_mask, verbose=verbose, cpus=args.workers)
            fit.save(os.path.join(outdir, args.responseout))

    # Force recalculate the response if response only is specified
    else:
        model = mtShoreModel(gtab, order, zeta, tau)
        fit = model.fit(data, dti_vecs, wm_mask, gm_mask, csf_mask, verbose=verbose)
        fit.save(os.path.join(outdir, args.responseout))

    # Deconvolution if 'responseonly' is not set
    if not args.responseonly:
        out, wmout, gmout, csfout = fit.fodf(data, pos=args.constraint, mask=dti_mask,
                                             verbose=verbose, cpus=args.workers)

        fields.save_tensor(os.path.join(args.outdir, "fodf.nrrd"), out, mask=dti_mask.get_data(), meta=meta)

        # Save volumes
        fields.save_scalar(os.path.join(args.outdir, "wmvolume.nrrd"), wmout, meta)
        fields.save_scalar(os.path.join(args.outdir, "gmvolume.nrrd"), gmout, meta)
        fields.save_scalar(os.path.join(args.outdir, "csfvolume.nrrd"), csfout, meta)

if __name__ == "__main__":
    main()
